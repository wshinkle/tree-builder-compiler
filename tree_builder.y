%{
#include <stdio.h>
#include <stdarg.h>
#include "bash.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// data structure to hold a linked list of arguments for a command
struct args {
    char *arg;
    struct args *next;
};

// data structure to hold a linked list of redirections for a command
struct redirs {
    int redir_token;
	char *filename;
    struct redirs *next;
};


/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
    struct args *pargs;
    struct redirs *predir;
    int number;
}



%token EOLN PIPE EQUALS
%token INFILE					// standard input redirection
%token OUTFILE OUTFILE_APPEND	// standard output redirection
%token ERRFILE ERRFILE_APPEND	// standard error redirection
%token <string> WORD QUOTED_STRING ERROR

%type <pcmd> line cmd	// main datatype from bash.h
%type <pargs> optargs arg
%type <predir> optredirs redir
  

%% 	/* beginning of the parsing rules	*/
input	: lines
	|
  	;

lines	: oneline
	| oneline lines
	;

oneline : line eoln
		{ doline($1); }
 	| eoln	/* blank line, do nothing */
	| error eoln
	/* if we got an error on the line, don't call the C program */
	;

eoln	: EOLN
		{ ++lines; }
	;


// you need to finish the rest of this...
line	: cmd
		{
			// cmd is a datastructure, pass it upstream
			$$ = $1;
		}
		| WORD EQUALS WORD
		{	
			//allocate new command struct
			$$ = (struct command *) MallocZ(sizeof(struct command));
			//set no error and env variable recognized
			$$->error_check=0;
			$$->env_var=1;
			//set command equal to whatever before equals
			$$->command = $1;
			//set argv[0] equal to whatever before equals
			$$->argv[0] = $1;
			//set argv[1] equal to whatever after equals
			$$->argv[1] = $3;
			
		}
		| WORD EQUALS
		{	
			//allocate new command struct
			$$ = (struct command *) MallocZ(sizeof(struct command));
			//set no error and env variable recognized
			$$->error_check=0;
			$$->env_var=1;
			//set command to whatever before equals
			$$->command = $1;
			//set argv[0] equal to whatever before equals
			$$->argv[0] = $1;
			
		}
		| cmd PIPE line
			{
				// cmd and line are both datastructures, hook them together in a linked list
				char *pipe_string = "PIPE";
				//allocate new command struct
				$$ = (struct command *) MallocZ(sizeof(struct command));
				$$->error_check=0;
				$$->env_var=0;
				//make return value equal to cmd
				$$ = $1; 
				//make return value next command equal to whatever after pipe
				$$ -> next = $3;
				if ($$ -> outfile != NULL || $$->next->infile != NULL) {yyerror("illegal redirection"); $$->error_check=1;} 
				//if shit makes sense set the outfile and infile to pipe string
				else {
					$$->outfile = pipe_string;
					$$->next->infile= pipe_string;
				}
				 
			}

		;

// FINISH THIS
cmd	: WORD optargs optredirs
		{
			// make and fill node of type "struct command "
			struct command *pcmd; 
			pcmd = (struct command *) MallocZ(sizeof(struct command));
			pcmd->command = $1;
			
			//create arguments linked list
			struct args *argum = (struct args *) MallocZ(sizeof(struct args));
			//set argum struct equal to optargs
			argum = $2;
			
			pcmd->argv[0] = pcmd->command;
			pcmd->argc = 1;
			for (int i = 1; argum != NULL; ++i) {
				pcmd->argv[i] = argum->arg;
				argum=argum->next;
				++pcmd->argc;
			}
			
			pcmd->output_append=0;
			pcmd->error_append=0;

			//allocate redir struct
			struct redirs *redir = (struct redirs *) MallocZ(sizeof(struct redirs));
			//set redir equal to optredirs
			redir = $3;

			//while there are redirs
			while (redir != NULL) {
				if (redir->redir_token == 1) {
					if (pcmd->infile != NULL) {
						yyerror("illegal redirection"); 
						pcmd->error_check = 1;
					} 
					else {pcmd->infile = redir->filename;}}
				if (redir->redir_token == 2) {
					if (pcmd->outfile != NULL) {
						yyerror("illegal redirection"); 
						pcmd->error_check = 1;
					} 
					else {pcmd->outfile = redir->filename;}}
				if (redir->redir_token == 3) {
					if (pcmd->outfile != 0) {
						yyerror("illegal redirection");
						pcmd->error_check = 1;
					} 
					else {
						pcmd->outfile = redir->filename; 
						pcmd->output_append=1;
					}
				}
				if (redir->redir_token == 4) {
					if (pcmd->errfile != NULL) {
						yyerror("illegal redirection"); 
						pcmd->error_check = 1;
					} 
					else {pcmd->errfile = redir->filename;}}
				if (redir->redir_token == 5) {
					if (pcmd->errfile != 0) {
						yyerror("illegal redirection");
						pcmd->error_check = 1;
					} 
					else {
						pcmd->errfile = redir->filename; 
						pcmd->error_append=1;
					}
				}
				redir = redir->next;	
			}
			$$ = pcmd;
		}
	;

// FINISH THIS
// these 2 rules are for "optional arguments".  They should allow one or more "arg"s
// and assemble them into a linked list of type "struct args" and return it upstead
optargs : arg optargs
			{ 
				$$ = (struct args *) MallocZ(sizeof(struct args));
				$$ = $1;
				$$->next = $2;
			}
		|	
			{ 
				$$ = NULL;
			}
		;
arg		: QUOTED_STRING {
			$$ = (struct args *) MallocZ(sizeof(struct args));
			printf("%s", $1);
			$$->arg = $1;
		}

		| WORD
		{
			$$ = (struct args *) MallocZ(sizeof(struct args));
			$$->arg = $1;
		}
		| ERROR 
		{
			YYERROR;
		}
		;


// FINISH THIS
// these 2 rules are for "optional redirection".  They should  allow one or more sets of 
// redirection commands from the rule "redir"
// and assemble them into a linked list of type "struct redir" and return it upstead
optredirs : redir optredirs
			{ 	
				$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
				$$ = $1;
				$$->next = $2;

			}
		|
			{ 
				$$ = NULL; // no more redirection 
			}
		;
// just as a possible example		
redir	: INFILE WORD
		{ 
			$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
		  	$$->redir_token = 1;
			$$->filename = $2;
		}
		| OUTFILE WORD {
			$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
		  	$$->redir_token = 2;
			$$->filename = $2;
		}
		| OUTFILE_APPEND WORD {
			$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
		  	$$->redir_token = 3;
			$$->filename = $2;
		}
		| ERRFILE WORD {
			$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
		  	$$->redir_token = 4;
			$$->filename = $2;
		}
		| ERRFILE_APPEND WORD {$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
		  	$$->redir_token = 5;
			$$->filename = $2;}
		;

%%

void
yyerror(const char *error_string, ...)
{
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;

    fprintf(f,"Error on line %d: ", lines+ 1);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}

// You should use this routine instead of malloc() to avoid some memory problems
#include <stdlib.h>
#include <string.h>
void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);  // use the real routine
    if (ptr == NULL)
	{
	    perror ("MallocZ failed, fatal\n");
	    exit (66);
	}

	// initialize the space to all zeroes
    memset (ptr, '\00', nbytes);

    return (ptr);
}